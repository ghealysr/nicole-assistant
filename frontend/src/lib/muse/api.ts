/**
 * Muse Design Research Agent - API Client
 * 
 * Provides interface for design research, mood board generation,
 * and style guide creation.
 */

import { getAuthHeaders } from '@/lib/alphawave_utils';

const API_BASE = process.env.NEXT_PUBLIC_API_URL || 'https://api.nicole.alphawavetech.com';

// ============================================================================
// TYPES
// ============================================================================

export interface CreateSessionRequest {
  project_id: number;
  design_brief: string;
  target_audience?: string;
  brand_keywords?: string[];
  aesthetic_preferences?: string;
  anti_patterns?: string;
}

export interface CreateSessionResponse {
  session_id: number;
  status: string;
  message: string;
}

export interface AddInspirationRequest {
  input_type: 'image' | 'url';
  data: string;
  user_notes?: string;
  focus_elements?: string[];
  filename?: string;
  mime_type?: string;
}

export interface SessionStatus {
  session_id: number;
  status: string;
  current_phase: string;
  phase_progress: number;
  phase_message?: string;
  estimated_cost: number;
  has_moodboards: boolean;
  has_style_guide: boolean;
}

export interface SessionDetails extends SessionStatus {
  project_id: number;
  design_brief: string;
  target_audience?: string;
  brand_keywords?: string[];
  aesthetic_preferences?: string;
  anti_patterns?: string;
  brief_analysis?: Record<string, unknown>;
  moodboard_count: number;
  selected_moodboard_id?: number;
  created_at?: string;
}

export interface InspirationInput {
  id: number;
  type: 'image' | 'url';
  input_type?: 'image' | 'url'; // Legacy alias
  data: string;
  notes?: string;
  preview_url?: string;
  filename?: string;
  url?: string;
  user_notes?: string;
  focus_elements?: string[];
  analysis_complete?: boolean;
  applicability_score?: number;
  created_at?: string;
}

/**
 * MoodBoard represents a design direction option generated by Muse.
 * 
 * Key fields:
 * - `name`: Canonical display name (e.g., "Atomic Elegance")
 * - `preview_image_b64`: AI-generated visual preview (base64 PNG)
 * - `color_palette`: Full color specification
 * - `colors`: Simplified color array for UI display
 */
export interface MoodBoard {
  /** Unique identifier */
  id: number;
  /** Position in the list (1-4 typically) */
  option_number: number;
  /** Display name - use this for UI rendering */
  name: string;
  /** Backend alias for name - prefer `name` in frontend */
  title?: string;
  /** Design direction description */
  description: string;
  /** Primary aesthetic movement (e.g., "Neo-Brutalism", "Swiss Minimalism") */
  aesthetic_movement: string;
  /** Emotional qualities (e.g., ["bold", "professional", "innovative"]) */
  emotional_tone: string[];
  /** Simplified color array for UI display */
  colors: Array<{ name: string; hex: string; oklch?: string }>;
  /** Full color palette specification */
  color_palette?: {
    primary: string;
    secondary: string;
    accent: string;
    background: string;
    surface: string;
    text_primary: string;
    text_secondary: string;
    [key: string]: string;
  };
  /** Typography specification */
  typography: {
    heading: string;
    body: string;
    heading_font?: string;
    heading_font_url?: string;
    body_font?: string;
    body_font_url?: string;
    font_rationale?: string;
  };
  /** Imagery direction */
  imagery_style: string;
  /** Layout approach description */
  layout_philosophy: string;
  /** Motion/animation approach */
  motion_philosophy: string;
  /** Whether this mood board is currently selected */
  is_selected: boolean;
  /** AI-generated preview image (base64 encoded PNG from Imagen 3) */
  preview_image_b64?: string;
  /** Legacy preview data */
  preview?: Record<string, unknown>;
  /** A/B testing: number of times this aesthetic has been selected */
  selection_count?: number;
}

export interface StyleGuide {
  id: number;
  version: number;
  is_approved: boolean;
  colors: {
    primary?: Array<{ name: string; hex: string; oklch?: string }>;
    secondary?: Array<{ name: string; hex: string; oklch?: string }>;
    accent?: Array<{ name: string; hex: string; oklch?: string }>;
    neutral?: Array<{ name: string; hex: string; oklch?: string }>;
    semantic?: Array<{ name: string; hex: string; oklch?: string }>;
    [key: string]: Array<{ name: string; hex: string; oklch?: string }> | undefined;
  };
  typography: {
    families?: Record<string, string>;
    scale?: Record<string, string>;
    [key: string]: unknown;
  };
  spacing: {
    base?: number;
    scale?: Record<string, number>;
    [key: string]: unknown;
  };
  radii?: Record<string, string>;
  shadows?: Record<string, string>;
  animations?: Record<string, unknown>;
  breakpoints?: Record<string, string>;
  component_specs?: Record<string, unknown>;
  components?: Record<string, unknown>;
  iconography?: {
    library: string;
    style: string;
  };
  imagery_guidelines?: string;
  anti_patterns?: string[];
  tailwind_config?: Record<string, unknown>;
  css_variables?: string;
  implementation_notes?: string;
  nicole_context_summary?: string;
}

export interface MuseEvent {
  type: string;
  data: Record<string, unknown>;
  timestamp: string;
}

export interface StyleGuideExport {
  format: string;
  content: string;
  filename: string;
  content_type: string;
}

export type ExportFormat = 'figma_tokens' | 'css_variables' | 'tailwind_config' | 'design_tokens_json';

// ============================================================================
// API CLIENT
// ============================================================================

class MuseAPI {
  private baseUrl = `${API_BASE}/muse`;

  private async request<T>(
    endpoint: string,
    options: RequestInit = {}
  ): Promise<T> {
    const url = `${this.baseUrl}${endpoint}`;
    const headers = await getAuthHeaders();

    const response = await fetch(url, {
      ...options,
      headers: {
        ...headers,
        'Content-Type': 'application/json',
        ...options.headers,
      },
    });

    if (!response.ok) {
      const errorData = await response.json().catch(() => ({}));
      throw new Error(errorData.detail || `HTTP ${response.status}`);
    }

    return response.json();
  }

  // ==========================================================================
  // HEALTH CHECK
  // ==========================================================================

  async checkHealth(): Promise<{ available: boolean; message: string }> {
    return this.request('/health');
  }

  // ==========================================================================
  // SESSION MANAGEMENT
  // ==========================================================================

  async createSession(request: CreateSessionRequest): Promise<CreateSessionResponse> {
    return this.request('/sessions', {
      method: 'POST',
      body: JSON.stringify(request),
    });
  }

  async getSession(sessionId: number): Promise<SessionDetails> {
    return this.request(`/sessions/${sessionId}`);
  }

  async getSessionStatus(sessionId: number): Promise<SessionStatus> {
    return this.request(`/sessions/${sessionId}/status`);
  }

  async getProjectSession(projectId: number): Promise<{ active_session: SessionStatus | null }> {
    return this.request(`/projects/${projectId}/session`);
  }

  // ==========================================================================
  // INSPIRATION INPUTS
  // ==========================================================================

  async addInspiration(
    sessionId: number,
    request: AddInspirationRequest
  ): Promise<{ input_id: number; message: string }> {
    return this.request(`/sessions/${sessionId}/inspirations`, {
      method: 'POST',
      body: JSON.stringify(request),
    });
  }

  async listInspirations(sessionId: number): Promise<{ inspirations: InspirationInput[] }> {
    return this.request(`/sessions/${sessionId}/inspirations`);
  }

  async deleteInspiration(sessionId: number, inputId: number): Promise<{ message: string }> {
    return this.request(`/sessions/${sessionId}/inspirations/${inputId}`, {
      method: 'DELETE',
    });
  }

  // ==========================================================================
  // RESEARCH PIPELINE
  // ==========================================================================

  async startResearch(
    sessionId: number,
    moodboardCount: number = 4
  ): Promise<{
    success: boolean;
    status: string;
    moodboard_count?: number;
    message: string;
    error?: string;
  }> {
    return this.request(`/sessions/${sessionId}/start?moodboard_count=${moodboardCount}`, {
      method: 'POST',
    });
  }

  /**
   * Stream research events via SSE.
   * Returns an EventSource that emits progress updates.
   * 
   * NOTE: For frontend use, prefer the useMuseStream hook which handles
   * authentication and provides React state integration.
   */
  streamEvents(sessionId: number, authToken?: string): EventSource {
    const tokenParam = authToken ? `?token=${encodeURIComponent(authToken)}` : '';
    const url = `${this.baseUrl}/sessions/${sessionId}/events${tokenParam}`;
    return new EventSource(url);
  }

  /**
   * Stream research events for a project via SSE.
   * Convenience method that uses project_id instead of session_id.
   */
  streamProjectEvents(projectId: number, authToken?: string): EventSource {
    const tokenParam = authToken ? `?token=${encodeURIComponent(authToken)}` : '';
    const url = `${this.baseUrl}/projects/${projectId}/stream${tokenParam}`;
    return new EventSource(url);
  }

  /**
   * Start research with streaming SSE updates.
   * Provides real-time progress including mood board generation with AI previews.
   * 
   * @param sessionId - Research session ID
   * @param options - Configuration options
   * @returns EventSource for real-time updates
   */
  startResearchStreaming(
    sessionId: number,
    options: {
      moodboardCount?: number;
      skipWebResearch?: boolean;
      generatePreviews?: boolean;
      authToken?: string;
    } = {}
  ): EventSource {
    const params = new URLSearchParams();
    if (options.moodboardCount) params.set('moodboard_count', options.moodboardCount.toString());
    if (options.skipWebResearch) params.set('skip_web_research', 'true');
    if (options.generatePreviews !== undefined) params.set('generate_previews', options.generatePreviews.toString());
    if (options.authToken) params.set('token', options.authToken);
    
    const queryString = params.toString();
    const url = `${this.baseUrl}/sessions/${sessionId}/start-streaming${queryString ? `?${queryString}` : ''}`;
    return new EventSource(url);
  }

  // ==========================================================================
  // MOOD BOARDS
  // ==========================================================================

  async listMoodboards(sessionId: number): Promise<{ moodboards: MoodBoard[] }> {
    return this.request(`/sessions/${sessionId}/moodboards`);
  }

  async getMoodboard(sessionId: number, moodboardId: number): Promise<MoodBoard> {
    return this.request(`/sessions/${sessionId}/moodboards/${moodboardId}`);
  }

  async selectMoodboard(
    sessionId: number,
    moodboardId: number,
    selectionNotes?: string,
    timeViewingSeconds?: number
  ): Promise<{
    success: boolean;
    message: string;
    status: string;
    style_guide_preview: {
      colors: string[];
      typography_families: string[];
      anti_patterns_count: number;
    };
  }> {
    return this.request(`/sessions/${sessionId}/moodboards/${moodboardId}/select`, {
      method: 'POST',
      body: JSON.stringify({ 
        moodboard_id: moodboardId, 
        selection_notes: selectionNotes,
        time_viewing_seconds: timeViewingSeconds
      }),
    });
  }
  
  /**
   * Track when a user views a mood board (for A/B testing).
   */
  async trackMoodboardImpression(
    sessionId: number,
    moodboardId: number,
    viewDurationSeconds?: number
  ): Promise<{ success: boolean; tracked: string }> {
    const params = viewDurationSeconds 
      ? `?view_duration_seconds=${viewDurationSeconds}` 
      : '';
    return this.request(
      `/sessions/${sessionId}/moodboards/${moodboardId}/impression${params}`,
      { method: 'POST' }
    );
  }
  
  /**
   * Get A/B testing analytics for a session's mood boards.
   */
  async getSessionAnalytics(sessionId: number): Promise<{
    session_id: number;
    moodboards: Array<{
      id: number;
      title: string;
      aesthetic_movement: string;
      total_selections: number;
      impressions: number;
      selections: number;
    }>;
  }> {
    return this.request(`/sessions/${sessionId}/analytics`);
  }

  async regenerateMoodboards(
    sessionId: number,
    count: number = 4
  ): Promise<{ success: boolean; count: number; message: string }> {
    return this.request(`/sessions/${sessionId}/moodboards/regenerate?count=${count}`, {
      method: 'POST',
    });
  }

  // ==========================================================================
  // STYLE GUIDE
  // ==========================================================================

  async getStyleGuide(sessionId: number): Promise<StyleGuide> {
    return this.request(`/sessions/${sessionId}/style-guide`);
  }

  async requestStyleGuideChanges(
    sessionId: number,
    feedback: string
  ): Promise<{ success: boolean; message: string; version: number }> {
    return this.request(`/sessions/${sessionId}/style-guide/revise`, {
      method: 'POST',
      body: JSON.stringify({ feedback }),
    });
  }

  async approveDesign(sessionId: number): Promise<{
    success: boolean;
    message: string;
    handoff: Record<string, unknown>;
    next_step: string;
  }> {
    return this.request(`/sessions/${sessionId}/approve`, {
      method: 'POST',
    });
  }

  async getHandoff(sessionId: number): Promise<Record<string, unknown>> {
    return this.request(`/sessions/${sessionId}/handoff`);
  }

  // ==========================================================================
  // SKIP RESEARCH
  // ==========================================================================

  async skipResearch(projectId: number): Promise<{
    success: boolean;
    message: string;
    design_mode: string;
  }> {
    return this.request(`/projects/${projectId}/skip-research`, {
      method: 'POST',
    });
  }

  // ==========================================================================
  // CONVENIENCE METHODS (for DesignDashboard compatibility)
  // ==========================================================================

  /**
   * Get session for a project (convenience wrapper)
   */
  async getSessionByProject(projectId: number): Promise<SessionDetails | null> {
    try {
      const result = await this.getProjectSession(projectId);
      if (result.active_session) {
        return await this.getSession(result.active_session.session_id);
      }
      return null;
    } catch {
      return null;
    }
  }

  /**
   * Get mood boards for a project
   */
  async getMoodBoards(projectId: number): Promise<MoodBoard[]> {
    const session = await this.getSessionByProject(projectId);
    if (!session) return [];
    const result = await this.listMoodboards(session.session_id);
    return result.moodboards;
  }

  /**
   * Select mood board by index
   */
  async selectMoodBoard(
    projectId: number,
    request: { selected_index: number }
  ): Promise<void> {
    const session = await this.getSessionByProject(projectId);
    if (!session) throw new Error('No active session');
    const moodboards = await this.listMoodboards(session.session_id);
    const selectedMoodboard = moodboards.moodboards[request.selected_index];
    if (!selectedMoodboard) throw new Error('Invalid moodboard index');
    await this.selectMoodboard(session.session_id, selectedMoodboard.id);
  }

  /**
   * Get style guide for a project
   */
  async getProjectStyleGuide(projectId: number): Promise<StyleGuide | null> {
    const session = await this.getSessionByProject(projectId);
    if (!session) return null;
    return this.getStyleGuide(session.session_id);
  }

  /**
   * Approve design for a project
   */
  async approveProjectDesign(projectId: number): Promise<void> {
    const session = await this.getSessionByProject(projectId);
    if (!session) throw new Error('No active session');
    await this.approveDesign(session.session_id);
  }

  /**
   * Start research with inspirations (convenience wrapper)
   */
  async startResearchWithInspirations(
    projectId: number,
    request: StartResearchRequest
  ): Promise<{ session_id: number }> {
    // Create session
    const sessionResponse = await this.createSession({
      project_id: projectId,
      design_brief: request.brief,
    });

    // Add inspiration images
    for (const imageB64 of request.inspiration_images_b64) {
      await this.addInspiration(sessionResponse.session_id, {
        input_type: 'image',
        data: imageB64,
      });
    }

    // Add inspiration URLs
    for (const url of request.inspiration_links) {
      await this.addInspiration(sessionResponse.session_id, {
        input_type: 'url',
        data: url,
      });
    }

    // Start research
    await this.startResearch(sessionResponse.session_id);
    
    return { session_id: sessionResponse.session_id };
  }

  // ==========================================================================
  // STYLE GUIDE EXPORT
  // ==========================================================================

  /**
   * Export a style guide in the specified format.
   */
  async exportStyleGuide(
    styleGuideId: number,
    format: 'figma_tokens' | 'css_variables' | 'tailwind_config' | 'design_tokens_json'
  ): Promise<StyleGuideExport> {
    return this.request(`/style-guides/${styleGuideId}/export`, {
      method: 'POST',
      body: JSON.stringify({ format }),
    });
  }

  /**
   * Get export history for a style guide.
   */
  async getExportHistory(styleGuideId: number): Promise<{
    style_guide_id: number;
    exports: Array<{
      id: number;
      format: string;
      created_at: string;
    }>;
  }> {
    return this.request(`/style-guides/${styleGuideId}/exports`);
  }

  /**
   * Quick export - export the active style guide for a project.
   */
  async exportProjectStyleGuide(
    projectId: number,
    format: 'figma_tokens' | 'css_variables' | 'tailwind_config' | 'design_tokens_json'
  ): Promise<{
    project_id: number;
    format: string;
    content: string;
    filename: string;
    content_type: string;
  }> {
    return this.request(`/projects/${projectId}/style-guide/export?format=${format}`);
  }

  /**
   * Download a style guide export as a file.
   */
  async downloadStyleGuideExport(
    projectId: number,
    format: 'figma_tokens' | 'css_variables' | 'tailwind_config' | 'design_tokens_json'
  ): Promise<void> {
    const result = await this.exportProjectStyleGuide(projectId, format);
    
    // Create blob and download
    const blob = new Blob([result.content], { type: result.content_type });
    const url = window.URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = result.filename;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    window.URL.revokeObjectURL(url);
  }
}

// Request type for DesignDashboard
export interface StartResearchRequest {
  brief: string;
  inspiration_images_b64: string[];
  inspiration_links: string[];
  skip_research: boolean;
}

export const museApi = new MuseAPI();

