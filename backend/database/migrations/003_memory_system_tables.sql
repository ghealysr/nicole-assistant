-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- Nicole V7 - Complete Memory System Tables (Tiger Postgres Native)
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- 
-- This migration creates the full memory system infrastructure:
-- - knowledge_bases: Hierarchical organization of memories
-- - memory_tags: Flexible tagging with AI auto-tagging
-- - memory_tag_links: Many-to-many tag assignments
-- - memory_links: Relationship mapping between memories
-- - memory_consolidations: Merged/summarized memory tracking
-- - nicole_actions: Audit log of Nicole's proactive actions
--
-- Prerequisites: 001_complete_tiger_schema.sql, 002_memory_functions.sql
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

-- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
-- KNOWLEDGE BASES TABLE
-- Organizes memories into projects, topics, or domains
-- Supports hierarchical structure (folders within folders)
-- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

CREATE TYPE kb_type_enum AS ENUM (
    'project',      -- Work projects, coding projects
    'topic',        -- Learning topics, interests
    'client',       -- Client-specific knowledge
    'personal',     -- Personal life organization
    'family',       -- Family-related memories
    'health',       -- Health and wellness
    'financial',    -- Financial matters
    'system'        -- Nicole's internal organization
);

CREATE TABLE IF NOT EXISTS knowledge_bases (
    kb_id BIGSERIAL PRIMARY KEY,
    
    -- Ownership
    user_id BIGINT NOT NULL REFERENCES users(user_id) ON DELETE CASCADE,
    
    -- Organization
    name TEXT NOT NULL,
    description TEXT,
    icon TEXT DEFAULT 'ğŸ“',
    color TEXT DEFAULT '#B8A8D4',
    
    -- Hierarchy (NULL = root level)
    parent_id BIGINT REFERENCES knowledge_bases(kb_id) ON DELETE CASCADE,
    
    -- Classification
    kb_type kb_type_enum NOT NULL DEFAULT 'topic',
    
    -- Sharing (for family memories)
    is_shared BOOLEAN DEFAULT FALSE,
    shared_with BIGINT[] DEFAULT '{}',
    
    -- Metadata (denormalized for performance)
    memory_count INTEGER DEFAULT 0,
    last_memory_at TIMESTAMPTZ,
    
    -- Timestamps
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    archived_at TIMESTAMPTZ,
    
    -- Who created this KB
    created_by TEXT DEFAULT 'user' CHECK (created_by IN ('user', 'nicole', 'system')),
    
    -- Constraints
    CONSTRAINT valid_kb_hierarchy CHECK (kb_id != parent_id),
    CONSTRAINT unique_kb_name_per_user UNIQUE (user_id, name)
);

COMMENT ON TABLE knowledge_bases IS 'Organizes memories into hierarchical projects/topics. Nicole can create and manage these.';

-- Indexes for knowledge_bases
CREATE INDEX IF NOT EXISTS idx_kb_user ON knowledge_bases(user_id);
CREATE INDEX IF NOT EXISTS idx_kb_parent ON knowledge_bases(parent_id) WHERE parent_id IS NOT NULL;
CREATE INDEX IF NOT EXISTS idx_kb_type ON knowledge_bases(kb_type);
CREATE INDEX IF NOT EXISTS idx_kb_active ON knowledge_bases(user_id) WHERE archived_at IS NULL;


-- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
-- MEMORY TAGS TABLE
-- Flexible tagging system with AI auto-tagging capability
-- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

CREATE TYPE tag_type_enum AS ENUM (
    'system',       -- Predefined system tags (available to all)
    'custom',       -- User-created tags
    'auto',         -- Auto-generated by Nicole
    'emotion',      -- Emotional context tags
    'temporal',     -- Time-based tags
    'entity'        -- Named entity tags (people, places, things)
);

CREATE TABLE IF NOT EXISTS memory_tags (
    tag_id BIGSERIAL PRIMARY KEY,
    
    -- Ownership (NULL = system tag available to all)
    user_id BIGINT REFERENCES users(user_id) ON DELETE CASCADE,
    
    -- Tag details
    name TEXT NOT NULL,
    description TEXT,
    color TEXT DEFAULT '#9CA3AF',
    icon TEXT,
    
    -- Classification
    tag_type tag_type_enum NOT NULL DEFAULT 'custom',
    
    -- AI-generated tags metadata
    auto_criteria TEXT,  -- Criteria for auto-applying this tag
    confidence_threshold NUMERIC(3,2) DEFAULT 0.7,  -- Min confidence to auto-apply
    
    -- Usage tracking
    usage_count INTEGER DEFAULT 0,
    last_used_at TIMESTAMPTZ,
    
    -- Timestamps
    created_at TIMESTAMPTZ DEFAULT NOW(),
    
    -- Unique constraint per user (or system-wide for system tags)
    CONSTRAINT unique_tag_name UNIQUE NULLS NOT DISTINCT (user_id, name)
);

COMMENT ON TABLE memory_tags IS 'Flexible tagging system. System tags are shared, custom/auto tags are per-user.';

-- Indexes for memory_tags
CREATE INDEX IF NOT EXISTS idx_tags_user ON memory_tags(user_id);
CREATE INDEX IF NOT EXISTS idx_tags_type ON memory_tags(tag_type);
CREATE INDEX IF NOT EXISTS idx_tags_system ON memory_tags(tag_type) WHERE tag_type = 'system';
CREATE INDEX IF NOT EXISTS idx_tags_auto ON memory_tags(tag_type, user_id) WHERE tag_type = 'auto';


-- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
-- MEMORY TAG LINKS TABLE
-- Many-to-many relationship between memories and tags
-- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

CREATE TABLE IF NOT EXISTS memory_tag_links (
    link_id BIGSERIAL PRIMARY KEY,
    memory_id BIGINT NOT NULL REFERENCES memory_entries(memory_id) ON DELETE CASCADE,
    tag_id BIGINT NOT NULL REFERENCES memory_tags(tag_id) ON DELETE CASCADE,
    
    -- Assignment metadata
    assigned_at TIMESTAMPTZ DEFAULT NOW(),
    assigned_by TEXT DEFAULT 'user' CHECK (assigned_by IN ('user', 'nicole', 'system')),
    
    -- For AI-assigned tags, store the confidence
    confidence NUMERIC(3,2) DEFAULT 1.0,
    
    CONSTRAINT unique_memory_tag_link UNIQUE (memory_id, tag_id)
);

COMMENT ON TABLE memory_tag_links IS 'Links memories to their tags. Tracks who assigned and confidence.';

-- Indexes for memory_tag_links
CREATE INDEX IF NOT EXISTS idx_tag_links_memory ON memory_tag_links(memory_id);
CREATE INDEX IF NOT EXISTS idx_tag_links_tag ON memory_tag_links(tag_id);


-- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
-- MEMORY LINKS TABLE (Relationships)
-- Intelligent relationship mapping between memories
-- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

CREATE TYPE relationship_type_enum AS ENUM (
    'related_to',       -- General relation
    'contradicts',      -- Memory contradicts another (correction)
    'elaborates',       -- Memory adds detail to another
    'supersedes',       -- Memory replaces/updates another
    'derived_from',     -- Memory was created from another
    'references',       -- Memory references another
    'same_topic',       -- Memories are about same topic
    'same_entity',      -- Memories are about same person/thing
    'temporal_sequence' -- Memories are part of a sequence
);

CREATE TABLE IF NOT EXISTS memory_links (
    link_id BIGSERIAL PRIMARY KEY,
    
    -- The two related memories
    source_memory_id BIGINT NOT NULL REFERENCES memory_entries(memory_id) ON DELETE CASCADE,
    target_memory_id BIGINT NOT NULL REFERENCES memory_entries(memory_id) ON DELETE CASCADE,
    
    -- Relationship type
    relationship_type relationship_type_enum NOT NULL DEFAULT 'related_to',
    
    -- Relationship strength (0-1) - higher = stronger connection
    weight NUMERIC(3,2) DEFAULT 0.5 CHECK (weight BETWEEN 0 AND 1),
    
    -- Bidirectional flag - if true, relationship applies both ways
    bidirectional BOOLEAN DEFAULT FALSE,
    
    -- Who created this relationship
    created_by TEXT DEFAULT 'nicole' CHECK (created_by IN ('user', 'nicole', 'system')),
    
    -- AI reasoning for why this link was created
    reasoning TEXT,
    
    -- Timestamps
    created_at TIMESTAMPTZ DEFAULT NOW(),
    
    -- Constraints
    CONSTRAINT no_self_link CHECK (source_memory_id != target_memory_id),
    CONSTRAINT unique_memory_link UNIQUE (source_memory_id, target_memory_id, relationship_type)
);

COMMENT ON TABLE memory_links IS 'Intelligent relationship mapping between memories. Nicole uses this to understand connections.';

-- Indexes for memory_links
CREATE INDEX IF NOT EXISTS idx_links_source ON memory_links(source_memory_id);
CREATE INDEX IF NOT EXISTS idx_links_target ON memory_links(target_memory_id);
CREATE INDEX IF NOT EXISTS idx_links_type ON memory_links(relationship_type);
CREATE INDEX IF NOT EXISTS idx_links_weight ON memory_links(weight DESC) WHERE weight > 0.5;


-- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
-- MEMORY CONSOLIDATIONS TABLE
-- Tracks when memories are merged/summarized
-- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

CREATE TYPE consolidation_type_enum AS ENUM (
    'merge',        -- Multiple memories merged into one
    'summarize',    -- Long memory summarized
    'deduplicate',  -- Duplicate memories merged
    'upgrade'       -- Memory updated with new information
);

CREATE TABLE IF NOT EXISTS memory_consolidations (
    consolidation_id BIGSERIAL PRIMARY KEY,
    
    -- The consolidated (summary) memory
    result_memory_id BIGINT NOT NULL REFERENCES memory_entries(memory_id) ON DELETE CASCADE,
    
    -- Original memories that were merged (stored as array)
    source_memory_ids BIGINT[] NOT NULL,
    
    -- Consolidation metadata
    consolidation_type consolidation_type_enum NOT NULL,
    
    -- AI processing metadata
    reason TEXT,
    model_used TEXT DEFAULT 'claude-sonnet-4-20250514',
    
    -- Quality metrics
    similarity_score NUMERIC(3,2),  -- How similar were the source memories
    confidence NUMERIC(3,2) DEFAULT 0.8,
    
    -- Timestamps
    created_at TIMESTAMPTZ DEFAULT NOW()
);

COMMENT ON TABLE memory_consolidations IS 'Tracks memory consolidations. Maintains audit trail.';

-- Indexes
CREATE INDEX IF NOT EXISTS idx_consolidations_result ON memory_consolidations(result_memory_id);
CREATE INDEX IF NOT EXISTS idx_consolidations_type ON memory_consolidations(consolidation_type);


-- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
-- NICOLE'S ACTIONS TABLE
-- Audit log of Nicole's proactive memory management
-- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

CREATE TYPE nicole_action_type_enum AS ENUM (
    'create_memory',        -- Nicole created a new memory
    'update_memory',        -- Nicole updated a memory
    'archive_memory',       -- Nicole archived a memory
    'create_kb',            -- Nicole created a knowledge base
    'organize_memories',    -- Nicole moved memories to a KB
    'consolidate',          -- Nicole merged memories
    'create_tag',           -- Nicole created a tag
    'tag_memory',           -- Nicole added tags
    'link_memories',        -- Nicole created relationships
    'boost_confidence',     -- Nicole increased confidence
    'decay_applied',        -- Scheduled decay was applied
    'self_reflection',      -- Nicole performed self-reflection
    'pattern_detected'      -- Nicole detected a pattern
);

CREATE TYPE target_type_enum AS ENUM ('memory', 'knowledge_base', 'tag', 'link', 'user');

CREATE TABLE IF NOT EXISTS nicole_actions (
    action_id BIGSERIAL PRIMARY KEY,
    
    -- Action details
    action_type nicole_action_type_enum NOT NULL,
    
    -- Target of action
    target_type target_type_enum NOT NULL,
    target_id BIGINT NOT NULL,
    
    -- Context
    user_id BIGINT REFERENCES users(user_id) ON DELETE CASCADE,
    
    -- AI reasoning
    reason TEXT,
    context JSONB,
    
    -- Result
    success BOOLEAN DEFAULT TRUE,
    error_message TEXT,
    
    -- Metrics
    processing_time_ms INTEGER,
    tokens_used INTEGER,
    
    -- Timestamps
    created_at TIMESTAMPTZ DEFAULT NOW()
);

COMMENT ON TABLE nicole_actions IS 'Audit log of Nicole''s proactive memory management actions.';

-- Indexes
CREATE INDEX IF NOT EXISTS idx_nicole_actions_user ON nicole_actions(user_id);
CREATE INDEX IF NOT EXISTS idx_nicole_actions_type ON nicole_actions(action_type);
CREATE INDEX IF NOT EXISTS idx_nicole_actions_target ON nicole_actions(target_type, target_id);
CREATE INDEX IF NOT EXISTS idx_nicole_actions_date ON nicole_actions(created_at DESC);


-- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
-- ALTER memory_entries TABLE
-- Add columns for knowledge base and enhanced tracking
-- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

-- Add knowledge_base_id column if not exists
DO $$
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.columns 
        WHERE table_name = 'memory_entries' AND column_name = 'knowledge_base_id'
    ) THEN
        ALTER TABLE memory_entries 
        ADD COLUMN knowledge_base_id BIGINT REFERENCES knowledge_bases(kb_id) ON DELETE SET NULL;
    END IF;
END $$;

-- Add is_shared column if not exists
DO $$
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.columns 
        WHERE table_name = 'memory_entries' AND column_name = 'is_shared'
    ) THEN
        ALTER TABLE memory_entries ADD COLUMN is_shared BOOLEAN DEFAULT FALSE;
    END IF;
END $$;

-- Add parent_memory_id column if not exists
DO $$
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.columns 
        WHERE table_name = 'memory_entries' AND column_name = 'parent_memory_id'
    ) THEN
        ALTER TABLE memory_entries 
        ADD COLUMN parent_memory_id BIGINT REFERENCES memory_entries(memory_id) ON DELETE SET NULL;
    END IF;
END $$;

-- Index for knowledge base lookups
CREATE INDEX IF NOT EXISTS idx_memory_kb ON memory_entries(knowledge_base_id) WHERE knowledge_base_id IS NOT NULL;
CREATE INDEX IF NOT EXISTS idx_memory_shared ON memory_entries(is_shared) WHERE is_shared = TRUE;
CREATE INDEX IF NOT EXISTS idx_memory_parent ON memory_entries(parent_memory_id) WHERE parent_memory_id IS NOT NULL;


-- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
-- INSERT DEFAULT SYSTEM TAGS
-- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

INSERT INTO memory_tags (user_id, name, description, color, icon, tag_type) VALUES
    (NULL, 'important', 'High priority memory', '#EF4444', 'â­', 'system'),
    (NULL, 'verified', 'Confirmed accurate', '#10B981', 'âœ“', 'system'),
    (NULL, 'needs-review', 'May need correction', '#F59E0B', 'âš ï¸', 'system'),
    (NULL, 'outdated', 'Information may be stale', '#6B7280', 'ğŸ“…', 'system'),
    (NULL, 'personal', 'Personal/private', '#8B5CF6', 'ğŸ”’', 'system'),
    (NULL, 'family', 'Family related', '#EC4899', 'ğŸ‘¨â€ğŸ‘©â€ğŸ‘§â€ğŸ‘¦', 'system'),
    (NULL, 'work', 'Work/business related', '#3B82F6', 'ğŸ’¼', 'system'),
    (NULL, 'health', 'Health related', '#22C55E', 'ğŸ¥', 'system'),
    (NULL, 'financial', 'Financial matters', '#84CC16', 'ğŸ’°', 'system'),
    (NULL, 'emotional', 'Emotional context', '#F472B6', 'ğŸ’œ', 'system'),
    (NULL, 'routine', 'Daily routine/habit', '#06B6D4', 'ğŸ”„', 'system'),
    (NULL, 'preference', 'User preference', '#A855F7', 'ğŸ’¡', 'system'),
    (NULL, 'goal', 'Goal or aspiration', '#FBBF24', 'ğŸ¯', 'system'),
    (NULL, 'correction', 'Corrected information', '#F97316', 'âœï¸', 'system'),
    (NULL, 'relationship', 'About people/relationships', '#EC4899', 'ğŸ‘¥', 'system'),
    (NULL, 'location', 'About places/locations', '#14B8A6', 'ğŸ“', 'system'),
    (NULL, 'time-sensitive', 'Has expiration or deadline', '#DC2626', 'â°', 'system')
ON CONFLICT DO NOTHING;


-- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
-- TRIGGER FUNCTIONS
-- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

-- Function to update knowledge base memory count
CREATE OR REPLACE FUNCTION update_kb_memory_count()
RETURNS TRIGGER AS $$
BEGIN
    IF TG_OP = 'INSERT' AND NEW.knowledge_base_id IS NOT NULL THEN
        UPDATE knowledge_bases 
        SET memory_count = memory_count + 1,
            last_memory_at = NOW(),
            updated_at = NOW()
        WHERE kb_id = NEW.knowledge_base_id;
    ELSIF TG_OP = 'DELETE' AND OLD.knowledge_base_id IS NOT NULL THEN
        UPDATE knowledge_bases 
        SET memory_count = GREATEST(0, memory_count - 1),
            updated_at = NOW()
        WHERE kb_id = OLD.knowledge_base_id;
    ELSIF TG_OP = 'UPDATE' THEN
        IF OLD.knowledge_base_id IS DISTINCT FROM NEW.knowledge_base_id THEN
            IF OLD.knowledge_base_id IS NOT NULL THEN
                UPDATE knowledge_bases 
                SET memory_count = GREATEST(0, memory_count - 1),
                    updated_at = NOW()
                WHERE kb_id = OLD.knowledge_base_id;
            END IF;
            IF NEW.knowledge_base_id IS NOT NULL THEN
                UPDATE knowledge_bases 
                SET memory_count = memory_count + 1,
                    last_memory_at = NOW(),
                    updated_at = NOW()
                WHERE kb_id = NEW.knowledge_base_id;
            END IF;
        END IF;
    END IF;
    RETURN COALESCE(NEW, OLD);
END;
$$ LANGUAGE plpgsql;

-- Create trigger for memory count updates
DROP TRIGGER IF EXISTS trigger_update_kb_memory_count ON memory_entries;
CREATE TRIGGER trigger_update_kb_memory_count
    AFTER INSERT OR UPDATE OR DELETE ON memory_entries
    FOR EACH ROW EXECUTE FUNCTION update_kb_memory_count();

-- Function to increment tag usage count
CREATE OR REPLACE FUNCTION increment_tag_usage()
RETURNS TRIGGER AS $$
BEGIN
    UPDATE memory_tags 
    SET usage_count = usage_count + 1,
        last_used_at = NOW()
    WHERE tag_id = NEW.tag_id;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Create trigger for tag usage
DROP TRIGGER IF EXISTS trigger_increment_tag_usage ON memory_tag_links;
CREATE TRIGGER trigger_increment_tag_usage
    AFTER INSERT ON memory_tag_links
    FOR EACH ROW EXECUTE FUNCTION increment_tag_usage();


-- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
-- GRANTS
-- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

GRANT ALL ON knowledge_bases TO tsdbadmin;
GRANT ALL ON memory_tags TO tsdbadmin;
GRANT ALL ON memory_tag_links TO tsdbadmin;
GRANT ALL ON memory_links TO tsdbadmin;
GRANT ALL ON memory_consolidations TO tsdbadmin;
GRANT ALL ON nicole_actions TO tsdbadmin;

GRANT USAGE, SELECT ON ALL SEQUENCES IN SCHEMA public TO tsdbadmin;


-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- MIGRATION COMPLETE
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- 
-- Tables created:
--   âœ… knowledge_bases - Hierarchical memory organization
--   âœ… memory_tags - Flexible tagging with AI auto-tagging
--   âœ… memory_tag_links - Many-to-many tag assignments
--   âœ… memory_links - Intelligent relationship mapping
--   âœ… memory_consolidations - Merged memory tracking
--   âœ… nicole_actions - Audit log of Nicole's actions
--
-- Next: Apply this migration, then deploy the intelligent memory service
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

